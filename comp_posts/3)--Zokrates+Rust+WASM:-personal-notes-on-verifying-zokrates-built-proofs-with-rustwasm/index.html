<p><code>29 aug 2022</code></p>
<h1 id="introduction">Introduction</h1>
<p>Personal notes on writing a Rust verifier for zokrates-generated
veryifing key and proof, depending on my <code>ark-groth16</code> fork.
The fork is designed to target WebAssembly, effectively making it easily
cross-platform without issues, furthermore it leverages the amazing work
from the people at arkworks and isn’t depentent on Rust’s standard
library.</p>
<h1 id="workflow">Workflow</h1>
<p><code>arg-groth16</code>’s <code>verify_proof/3</code> function
accepts three parameters: a <code>PreparedVerifyingKey</code> struct,
the proof and the public inputs (these two have a familiar look).</p>
<p>The function seems to only accept the public inputs in a raw format,
while the verifying key must be prepared before through the
<code>prepare_verifying_key/1</code> function, which accepts a
<code>VerifyingKey</code> struct, which has a familiar look (to the one
built by zokrates).</p>
<p>It’s also worth noting that arkworks doesn’t seem to have implemented
the <code>alt_bn128</code> curve, probably also because it doesn’t <a
href="https://moderncrypto.org/mail-archive/curves/2016/000740.html">actually</a>
target 128bit security.</p>
<h1 id="possible-approach">Possible Approach</h1>
<p>Firstly, one should remember to compile the <code>zok</code> code
with the <code>--curve bls12_377</code> or
<code>--curve bls12_381</code>. Secondly, convert zokrates’ output from
hexadecimal to decimal numbers.</p>
<h2 id="building-required-structs">Building required structs</h2>
<h3 id="context">context</h3>
<pre data-rust=""><code>pub struct Proof&lt;E: PairingEngine&gt; {
    /// The `A` element in `G1`.
    pub a: E::G1Affine,
    /// The `B` element in `G2`.
    pub b: E::G2Affine,
    /// The `C` element in `G1`.
    pub c: E::G1Affine,
  }

  pub struct VerifyingKey&lt;E: PairingEngine&gt; {
    /// The `alpha * G`, where `G` is the generator of `E::G1`.
    pub alpha_g1: E::G1Affine,
    /// The `alpha * H`, where `H` is the generator of `E::G2`.
    pub beta_g2: E::G2Affine,
    /// The `gamma * H`, where `H` is the generator of `E::G2`.
    pub gamma_g2: E::G2Affine,
    /// The `delta * H`, where `H` is the generator of `E::G2`.
    pub delta_g2: E::G2Affine,
    /// The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where `H` is the generator of `E::G1`.
    pub gamma_abc_g1: Vec&lt;E::G1Affine&gt;,
  }

  pub struct PreparedVerifyingKey&lt;E: PairingEngine&gt; {
    /// The unprepared verification key.
    pub vk: VerifyingKey&lt;E&gt;,
    /// The element `e(alpha * G, beta * H)` in `E::GT`.
    pub alpha_g1_beta_g2: E::Fqk,
    /// The element `- gamma * H` in `E::G2`, prepared for use in pairings.
    pub gamma_g2_neg_pc: E::G2Prepared,
    /// The element `- delta * H` in `E::G2`, prepared for use in pairings.
    pub delta_g2_neg_pc: E::G2Prepared,
  }
  
  ...
  
  pub fn verify_proof&lt;E: PairingEngine&gt;(
    pvk: &amp;PreparedVerifyingKey&lt;E&gt;,
    proof: &amp;Proof&lt;E&gt;,
    public_inputs: &amp;[E::Fr],
  ) -&gt; R1CSResult&lt;bool&gt; {
    let prepared_inputs = prepare_inputs(pvk, public_inputs)?;
    verify_proof_with_prepared_inputs(pvk, proof, &amp;prepared_inputs)
  }
</code></pre>
<p>Where a <code>G1Affine</code> type looks like this:</p>
<pre><code>    GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    3199796192684432232,
                    4362044476736311684,
                    8571585415345326572,
                    272761253199814039,
                    14270748742047465361,
                    66582167681461772,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    17201133494176990532,
                    17361089997485303489,
                    2356170384171249648,
                    15902542869977172799,
                    4538038237916000288,
                    111600171191049399,
                ],
            ),
        ),
        infinity: false,
    },
</code></pre>
<p>And a <code>G2Affine</code> looks like this:</p>
<pre><code>    GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15665539495786463071,
                        5351637199640705349,
                        5481305661085202947,
                        7252742268448139825,
                        14247290886710085473,
                        8228118271073905,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        8494150025713109519,
                        10006396386444051476,
                        13426536016117885356,
                        14412411855199552289,
                        6775472512520061513,
                        74820872700629732,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15935296043123816371,
                        16352348468216685567,
                        18366972020740145783,
                        466661810096455046,
                        2878395169732749912,
                        8930570229618427,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5497740038271589360,
                        17915564786368593018,
                        6498524887710276130,
                        8426407821033307682,
                        16967503410483070288,
                        87176449986178953,
                    ],
                ),
            ),
        },
        infinity: false,
    },
</code></pre>
<p><strong>Note</strong>: the <code>BigInteger384</code> type seems to
hold the actual number as an array of smaller numbers (similar to what’s
being done with Soroban’s u256 integers). In fact, an array exacly
corresponds to a zokrates generated one (after being converted to
decimal).</p>
<p><strong>Note</strong>: the length of the numbers in
<code>BigInteger384</code>’s array varies between 17 and 20, I should do
some digging in why is that and if it affects the actual
computation.</p>
<h1 id="allocator-complains-optimizing-non-reuired-functions">Allocator
complains &amp; Optimizing non-reuired functions</h1>
<p>Since some WASM VMs don’t provide allocation for additional
resources, I have traced the source of the allocation, which seems to be
the <code>hashbrown</code> crate. This crate is needed for the
<code>ark-poly</code> crate, which however we don’t need since it’s only
used for the <code>circuit_specific_setup()</code> and
<code>prove()</code> functions, which have nothing to do with our
verifying function. I cannot however infer with the Trait since it’s
imported from the imported primitives crate. One solution would be to
fork both <code>ark-snark</code> and <code>ark-crypto-primitives</code>,
and change the trait to not have those two funcitons. It also seems that
we don’t need the implementation of <code>SNARK</code> for
<code>Groth16</code> at all.</p>
<h1 id="projective-representation">Projective representation</h1>
<p>Projective representations appears to be the key to porting numbers
to the affine representation without iplementing the transformation
myself. The <code>E::G1Projective</code> and
<code>E::G2Projective</code> implement the
<code>self.into_affine()</code> method thorugh inheritance.</p>
<p>Since I can create a field starting from an array of bytes that
represent a number:</p>
<pre><code>  let tst_bi: Fr = Field::from_random_bytes(&amp;10u8.to_ne_bytes()).unwrap();</code></pre>
<p>And this results in the following representation:</p>
<pre><code>Fp256(BigInteger256([11286724353632239479, 271994586681835377, 4576425507946680135, 164029952815760582]))</code></pre>
<p>Where <code>Fp256</code> is the same of the public inputs, which are
aggregated starting from the verifying key’s <code>gamma_abc</code>.</p>
<p>So I can build the key and then the <code>prepare_inputs()</code>
aggregates the public inputs to <span
class="math inline"><em>L̄</em></span> for me.</p>
<p>The verifying key is made up of <code>Fp384</code> types, which we
can construct like this:</p>
<pre><code>    let numm: Fp384&lt;FqParameters&gt; = Fp384::from_random_bytes(&amp;1u8.to_ne_bytes()).unwrap();</code></pre>
<p>Even better, we can construct a <code>G1Affine</code> directly from
the <code>Fp384</code> numbers:</p>
<pre><code>  fn af&lt;E&gt;(x: &amp;[u8], y: &amp;[u8]) -&gt; G1Affine
  where
  E: PairingEngine,
  {
    G1Affine::new(
    Fp384::from_random_bytes(x).unwrap(),
    Fp384::from_random_bytes(y).unwrap(),
    false,
    )
  }</code></pre>
<h2 id="final-verifying-key-approach">Final verifying key approach</h2>
<p>So this might be the final approach:</p>
<ol>
<li><p>get <span
class="math inline"><em>α</em> <em>β</em> <em>γ</em> <em>δ</em> <em>γ</em><sub><em>a</em><em>b</em><em>c</em></sub></span>
 as bytes.</p></li>
<li><p>build the Affine for those</p></li>
<li><p>use the <code>G1Affine</code> and <code>G2Affine</code> to build
the verifying key.</p></li>
</ol>
<h3 id="building-a-g1affine">Building a G1Affine</h3>
<pre><code>  fn af_g1&lt;E&gt;(x: &amp;[u8], y: &amp;[u8]) -&gt; G1Affine
  where
  E: PairingEngine,
  {
    G1Affine::new(
    Fp384::from_random_bytes(x).unwrap(),
    Fp384::from_random_bytes(y).unwrap(),
    false,
    )
  }</code></pre>
<h3 id="building-g2affine">Building G2Affine</h3>
<pre><code>  fn af_g2&lt;E&gt;(c0_x0: &amp;[u8], c1_y0: &amp;[u8], c0_x1: &amp;[u8], c1_y1: &amp;[u8]) -&gt; G2Affine
  where
  E: PairingEngine,
  {
    let x = QuadExtField::new(
    Fp384::from_random_bytes(c0_x0).unwrap(),
    Fp384::from_random_bytes(c1_y0).unwrap(),
    );
    let y = QuadExtField::new(
    Fp384::from_random_bytes(c0_x1).unwrap(),
    Fp384::from_random_bytes(c1_y1).unwrap(),
    );

    G2Affine::new(x, y, false)
  }</code></pre>
<h3 id="building-the-verifying-key-test">Building the verifying key
test</h3>
<p>Not yet completed, but seems to work correctly:</p>
<pre><code>  /// building a verifying key from provided bytes
  pub fn build_vk&lt;E&gt;(
  alpha_b: [&amp;[u8]; 2],
  beta_b: ([&amp;[u8]; 2], [&amp;[u8]; 2]),
  //    gamma_b: ([&amp;[u8]; 2], [&amp;[u8]; 2]),
  //    delta_b: ([&amp;[u8]; 2], [&amp;[u8]; 2]),
  //    gamma_abc_b: Vec&lt;[&amp;[u8]; 2]&gt;,
  //) -&gt; VerifyingKey&lt;E&gt;
  ) where
  E: PairingEngine,
  {
    let alpha = af_g1::&lt;E&gt;(alpha_b[0], alpha_b[1]);
    let beta = af_g2::&lt;E&gt;(beta_b.0[0], beta_b.0[1], beta_b.1[0], beta_b.1[1]);
    println!(&quot;{:#?}&quot;, beta);
  }

  #[test]
  fn test() {
    build_vk::&lt;Bls12_377&gt;(
    [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
    (
    [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
    [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
    ),
    )
  }

  ... TEST ...
  

  running 1 test
  GroupAffine {
    x: QuadExtField {
      c0: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
      c1: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
    },
    y: QuadExtField {
      c0: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
      c1: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
    },
    infinity: false,
  }
  test verifying_key_wrap::test ... ok

</code></pre>
<h2
id="building-a-verifying-key-using-bls12_377-as-pairing-engine">Building
a Verifying Key using BLS12_377 as pairing engine</h2>
<p>This is how to successfully build a verifying key starting from an
array of bytes using the BLS12_377 curve:</p>
<pre><code>
/// building a verifying key from provided bytes
pub fn build_vk&lt;E&gt;(
    alpha_b: [&amp;[u8]; 2],
    beta_b: ([&amp;[u8]; 2], [&amp;[u8]; 2]),
    gamma_b: ([&amp;[u8]; 2], [&amp;[u8]; 2]),
    delta_b: ([&amp;[u8]; 2], [&amp;[u8]; 2]),
    gamma_abc_b: &amp;[[&amp;[u8]; 2]],
    //) -&gt; VerifyingKey&lt;E&gt;
) where
    E: PairingEngine,
{
    let alpha = af_g1::&lt;E&gt;(alpha_b[0], alpha_b[1]);
    let beta = af_g2::&lt;E&gt;(beta_b.0[0], beta_b.0[1], beta_b.1[0], beta_b.1[1]);
    let gamma = af_g2::&lt;E&gt;(gamma_b.0[0], gamma_b.0[1], gamma_b.1[0], gamma_b.1[1]);
    let delta = af_g2::&lt;E&gt;(delta_b.0[0], delta_b.0[1], delta_b.1[0], delta_b.1[1]);

    let mut gamma_abc: Vec&lt;GroupProjective&lt;Parameters&gt;&gt; = Vec::new();
    for g in gamma_abc_b {
        gamma_abc.push(af_g1::&lt;E&gt;(g[0], g[1]).into_projective());
    }

    let vk = VerifyingKey::&lt;Bls12_377&gt; {
        alpha_g1: alpha,
        beta_g2: beta,
        gamma_g2: gamma,
        delta_g2: delta,
        gamma_abc_g1: &lt;Bls12_377 as PairingEngine&gt;::G1Projective::batch_normalization_into_affine(
            gamma_abc.as_slice(),
        ),
    };

    println!(&quot;{:#?}&quot;, vk);
}

#[test]
fn test() {
    build_vk::&lt;Bls12_377&gt;(
        [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
        (
            [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
            [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
        ),
        (
            [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
            [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
        ),
        (
            [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
            [&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()],
        ),
        &amp;[[&amp;0u8.to_be_bytes(), &amp;0u8.to_be_bytes()]],
    )
}

... TEST ...

running 1 test
VerifyingKey {
    alpha_g1: GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            ),
        ),
        infinity: false,
    },
    beta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    delta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_abc_g1: [
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            infinity: false,
        },
    ],
}
test verifying_key_wrap::test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>I have not yet tested it against a ark-groth16-generated verifying
key, but plan to do so by comparing a ark-groth16-built verifiying key
and one generated by my <code>build_vk</code>. That is possible since
the <code>GroupAffine</code> type implements a <code>to_string()</code>
method, which seems to return the number as a hash.</p>
<h3 id="test-0-starting-from-a-ark-circuit-generated-verifying-key">test
0: starting from a ark circuit generated verifying key</h3>
<pre><code>GroupAffine(x=Fp384 &quot;(019658A8FE2530371B8B69DDA1EB401D38ADE94CA012341DA661A988219CDEA79CEE092B535FF84E71C2A9A18957B881)&quot;, y=Fp384 &quot;(0069110BB0B7540F07D4AA367B6BD0C0DD3F8ADE8BF61CE5BFB718D3A64F7A13D425CC898EA11DCF59A065EEEDF0BB80)&quot;)


GroupAffine(x=QuadExtField(Fp384 &quot;(0115B326AC5BD37483FD538B2D1E914BA6F7C863C2F3C2C664B6F718DD270E3BA5BBB456B5DB9EE53A190F79D4C6EC07)&quot; + Fp384 &quot;(01AAC26F963D72A14D3374B8A0E2F3919921848267A146B08F8077183E1EA1F58F4B6E716832254C54CD4B784BB63046)&quot; * u), y=QuadExtField(Fp384 &quot;(00917DE6A0FE407E9AC8661EA4A3CD3A45693AA026CA83AF7537A97079672DF22559AABA58FF1AA657F8F628600C520D)&quot; + Fp384 &quot;(00CD6561476FEA8B20B46675ACA888155C2A3F32C8F0FDAD3EBABAB1CAC3EA8D89CDF16A4D559A727E5BDBAFFD27D357)&quot; * u))


GroupAffine(x=QuadExtField(Fp384 &quot;(0159A72D5384E07E28BBE807D2945A9D5E21A0D3FB230BCABBE3A8669D9772F47D7BBDE56225D0C06D93416604C42CA0)&quot; + Fp384 &quot;(002BEDC636630F36F508ECB593456B31C60E96862E0B1033BAEA9E17C78EF06614A1211BA2A1FA49918B4F30260BB2B9)&quot; * u), y=QuadExtField(Fp384 &quot;(0120FA0A58FA22365481F9BAAF845CBEBCE52791B3C269CB4DA95ADD32611F1554666058A28452CC1ED42DFB7CB0FFC2)&quot; + Fp384 &quot;(00588C780399437031637430EE0D4F427D68B2627D93339FB59C78E3C88CAD08709B3CBF99303E8B7E25286DA29F9C6C)&quot; * u))


GroupAffine(x=QuadExtField(Fp384 &quot;(012F4602517868B27E3F26FE6131EBE79C4C637AA02C85B04433C13903325A06AA31D2B311D5C95A75C4A92143F46DB7)&quot; + Fp384 &quot;(005344DB42F936BC1D1D766255C0C9AA420823921F1A28B56E8C09092EBC7CED987E5C6E0C5C4B61522556656467EF25)&quot; * u), y=QuadExtField(Fp384 &quot;(0108F393A29B95FB6C2AAD2FC7AD516231C85B3C47BAC3EDADEFA20730ED92FB37C36D054A217C0EB39015B5F0490A5B)&quot; + Fp384 &quot;(0130256282E62A9056F5823186D49CD941CA46A7748F3246838A8ED6681383919D5C9BFD4EE89B8D48C960A93227A723)&quot; * u))


+++++++++++++++++++++++

&quot;GroupAffine(x=Fp384 \&quot;(004B363793CEBFE34BCBB3473344E5BA962A068636DE228390DC9E327616454A05F8B6F3EF601E9212CCEF2977B65BAA)\&quot;, y=Fp384 \&quot;(002080555C69C79878802E49F5B6A8F6C2D1C9B8CAF48EBF9930F9A6FC02EBE906BCF8DC2F66BBF7374EF8E0BDB6D93A)\&quot;)&quot;
+++++++++++++++++++++++

&quot;GroupAffine(x=Fp384 \&quot;(00DCB332C40B11FEEF6F66AF4EC71FE05E2C2828D2035CD6B341494EA27BE24B8FFED97FBED4F77DF823A871D12BD71D)\&quot;, y=Fp384 \&quot;(018F59B773DA05F4075C7C1EBEFE3B9A94FBF00B4B4C195F28AE55276D9CD3AE92C17672E8B10E504387202599F16CB2)\&quot;)&quot;
VerifyingKey {
    alpha_g1: GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    3199796192684432232,
                    4362044476736311684,
                    8571585415345326572,
                    272761253199814039,
                    14270748742047465361,
                    66582167681461772,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    17201133494176990532,
                    17361089997485303489,
                    2356170384171249648,
                    15902542869977172799,
                    4538038237916000288,
                    111600171191049399,
                ],
            ),
        ),
        infinity: false,
    },
    beta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15665539495786463071,
                        5351637199640705349,
                        5481305661085202947,
                        7252742268448139825,
                        14247290886710085473,
                        8228118271073905,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        8494150025713109519,
                        10006396386444051476,
                        13426536016117885356,
                        14412411855199552289,
                        6775472512520061513,
                        74820872700629732,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15935296043123816371,
                        16352348468216685567,
                        18366972020740145783,
                        466661810096455046,
                        2878395169732749912,
                        8930570229618427,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5497740038271589360,
                        17915564786368593018,
                        6498524887710276130,
                        8426407821033307682,
                        16967503410483070288,
                        87176449986178953,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        9871853462335952088,
                        13818766888080895758,
                        17438042164113238682,
                        18189658193228720557,
                        2525422391418593468,
                        24523991538162966,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        11598746871527494840,
                        7034886688852915957,
                        12879249698997281788,
                        4163459272077291496,
                        8651220120244872545,
                        59915112257360239,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        7950359384402899170,
                        13996412715721629044,
                        6496880002162414242,
                        18295956382737944941,
                        2234543578719997617,
                        42753032893982425,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        10705544008056969210,
                        9200130017538406234,
                        11564099230850897960,
                        14834164197102901648,
                        8879627515244002516,
                        35758504385251159,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    delta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        17378376314876687378,
                        16973419638754281229,
                        14270724477782754208,
                        2501781286801870373,
                        15494869354494408847,
                        55959435810413563,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5502086789033988657,
                        14858517976162320987,
                        15404109653845145200,
                        2764116950063500718,
                        6191383125089685741,
                        50035813276305954,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        6015129980063650823,
                        16508026119111894092,
                        2188668545527179262,
                        6083766794835601109,
                        5406935781835772749,
                        5367335577955122,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        988948364683663604,
                        18317168497480206806,
                        1717381988724736342,
                        7919953277030105370,
                        568824204833211202,
                        155794729479942,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_abc_g1: [
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        11799971873841990394,
                        257913239514469713,
                        14278748961702997970,
                        5223660586048483536,
                        4755949232771428869,
                        55376713287789687,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        7153500734298768415,
                        12003322931069364582,
                        2971060553454058512,
                        10964891730829161335,
                        4028692683660537851,
                        108252529747732483,
                    ],
                ),
            ),
            infinity: false,
        },
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        12989544681776788439,
                        13832684143667388616,
                        3659190950442991324,
                        8388909368244242073,
                        14278530298672880819,
                        48707499247719728,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        1615753075891152131,
                        1664066684894824792,
                        13574419005665713030,
                        16927252680167286359,
                        3299211563813464259,
                        104982182247700143,
                    ],
                ),
            ),
            infinity: false,
        },
    ],
}</code></pre>
<p>With a small change in the <code>build_vk()</code> fn to accept
<code>&amp;str</code> instead of <code>&amp;[u8]</code>, it works
successfully (skipped the gamma_abc field since it’s already confirmed
it works).</p>
<pre><code>#[test]
fn test() {
    build_vk::&lt;Bls12_377&gt;(
        [&quot;244306343969063579670721716785298378635493726975886604273579756741639953229415532528173059841495385161051909109889&quot;, &quot;63168857095591134725408337287692176528875980900624529853774760091869452188562350014800651918572654790783920028544&quot;],
        (
            [&quot;166960595540395913540723923566898026573424078512165798770235854040187289225192916010951416820805112564604857674759&quot;, &quot;256579300865415868978670925736320544320874294516177433193882034907441551828751116120797786447763257652992433074246&quot;],
            [&quot;87473584283475883633210079642084278881337869703101638340970998916304987007252265651123549659939971414867340710413&quot;, &quot;123489609982310436708723271094904270617390265200237414568574960565923435716212526049371801011721780033997716837207&quot;],
        ),
        (
            [&quot;207815903344640726299046137491517455777565280776268931869703062519065330398931946294820126450478727867816749575328&quot;, &quot;26411179743201816196117502737770454887025628039998868349298819832115736570578946577905207881058063637557577233081&quot;],
            [&quot;173740578116962590398112557239635940705266404600901213439034068175852581397457477553437876533246152293969399185346&quot;, &quot;53237864274615109658005039249476166763817121546091535441125115325245366998581238918446431741630833736330879409260&quot;],
        ),
        (
            [&quot;182336170308948313274124544129583724669150178188157754550801543744233234403657037451296838109344679861568207613367&quot;, &quot;50063545199251041371514525798326822749409640809082086310504485485918817418911777413389911727510843283856035409701&quot;],
            [&quot;159295952166184899549579271167219255119055500588829231155055479006308616522384365458479858992918918801397710916187&quot;, &quot;182860777779699565903677389365895752934510027123821576636249379548577596319261062512490971767063470277595543086883&quot;]
        ),
        &amp;[[&quot;0&quot;, &quot;0&quot;]],
    )
}
</code></pre>
