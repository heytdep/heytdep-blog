\documentclass{article}

\usepackage{listings, listings-rust}
\usepackage{amsmath}% http://ctan.org/pkg/amsmath
\usepackage{color}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  
\lstset{  
tabsize=4,  
basicstyle=\ttfamily,  
backgroundcolor=\color{lbcolor},  
showstringspaces=false  
}
\newcommand{\inl}[1]{\lstinline{#1}}
\newcommand{\thickbar}[1]{\mathbf{\bar{\text{$#1$}}}}

\title{Zokrates+Rust+WASM}
\date{29/08/2022}

\begin{document}
\maketitle

\texttt{29 aug 2022}

\section{Introduction}

Personal notes on writing a Rust verifier for zokrates-generated veryifing key and proof, depending on my \lstinline{ark-groth16} fork. The fork is designed to target WebAssembly, effectively making it easily cross-platform without issues, furthermore it leverages the amazing work from the people at arkworks and isn't depentent on Rust's standard library.

\section{Workflow}
\lstinline{arg-groth16}'s \lstinline{verify_proof/3} function accepts three parameters: a \lstinline{PreparedVerifyingKey} struct, the proof and the public inputs (these two have a familiar look).

The function seems to only accept the public inputs in a raw format, while the verifying key must be prepared before through the \lstinline{prepare_verifying_key/1} function, which accepts a \lstinline{VerifyingKey} struct, which has a familiar look (to the one built by zokrates).

It's also worth noting that arkworks doesn't seem to have implemented the \lstinline{alt_bn128} curve, probably also because it doesn't \href{https://moderncrypto.org/mail-archive/curves/2016/000740.html}{actually} target 128bit security.

\section{Possible Approach}
Firstly, one should remember to compile the \lstinline{zok} code with the \lstinline{--curve bls12_377} or \lstinline{--curve bls12_381}. Secondly, convert zokrates' output from hexadecimal to decimal numbers.

\subsection{Building required structs}

\subsubsection{context}
\begin{lstlisting}[rust]
  pub struct Proof<E: PairingEngine> {
    /// The `A` element in `G1`.
    pub a: E::G1Affine,
    /// The `B` element in `G2`.
    pub b: E::G2Affine,
    /// The `C` element in `G1`.
    pub c: E::G1Affine,
  }

  pub struct VerifyingKey<E: PairingEngine> {
    /// The `alpha * G`, where `G` is the generator of `E::G1`.
    pub alpha_g1: E::G1Affine,
    /// The `alpha * H`, where `H` is the generator of `E::G2`.
    pub beta_g2: E::G2Affine,
    /// The `gamma * H`, where `H` is the generator of `E::G2`.
    pub gamma_g2: E::G2Affine,
    /// The `delta * H`, where `H` is the generator of `E::G2`.
    pub delta_g2: E::G2Affine,
    /// The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where `H` is the generator of `E::G1`.
    pub gamma_abc_g1: Vec<E::G1Affine>,
  }

  pub struct PreparedVerifyingKey<E: PairingEngine> {
    /// The unprepared verification key.
    pub vk: VerifyingKey<E>,
    /// The element `e(alpha * G, beta * H)` in `E::GT`.
    pub alpha_g1_beta_g2: E::Fqk,
    /// The element `- gamma * H` in `E::G2`, prepared for use in pairings.
    pub gamma_g2_neg_pc: E::G2Prepared,
    /// The element `- delta * H` in `E::G2`, prepared for use in pairings.
    pub delta_g2_neg_pc: E::G2Prepared,
  }
  
  ...
  
  pub fn verify_proof<E: PairingEngine>(
    pvk: &PreparedVerifyingKey<E>,
    proof: &Proof<E>,
    public_inputs: &[E::Fr],
  ) -> R1CSResult<bool> {
    let prepared_inputs = prepare_inputs(pvk, public_inputs)?;
    verify_proof_with_prepared_inputs(pvk, proof, &prepared_inputs)
  }

\end{lstlisting}

Where a \lstinline{G1Affine} type looks like this:

\begin{lstlisting}
    GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    3199796192684432232,
                    4362044476736311684,
                    8571585415345326572,
                    272761253199814039,
                    14270748742047465361,
                    66582167681461772,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    17201133494176990532,
                    17361089997485303489,
                    2356170384171249648,
                    15902542869977172799,
                    4538038237916000288,
                    111600171191049399,
                ],
            ),
        ),
        infinity: false,
    },

\end{lstlisting}

And a \lstinline{G2Affine} looks like this:

\begin{lstlisting}
    GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15665539495786463071,
                        5351637199640705349,
                        5481305661085202947,
                        7252742268448139825,
                        14247290886710085473,
                        8228118271073905,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        8494150025713109519,
                        10006396386444051476,
                        13426536016117885356,
                        14412411855199552289,
                        6775472512520061513,
                        74820872700629732,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15935296043123816371,
                        16352348468216685567,
                        18366972020740145783,
                        466661810096455046,
                        2878395169732749912,
                        8930570229618427,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5497740038271589360,
                        17915564786368593018,
                        6498524887710276130,
                        8426407821033307682,
                        16967503410483070288,
                        87176449986178953,
                    ],
                ),
            ),
        },
        infinity: false,
    },

\end{lstlisting}

\textbf{Note}: the \lstinline{BigInteger384} type seems to hold the actual number as an array of smaller numbers (similar to what's being done with Soroban's u256 integers). In fact, an array exacly corresponds to a zokrates generated one (after being converted to decimal).

\textbf{Note}: the length of the numbers in \lstinline{BigInteger384}'s array varies between 17 and 20, I should do some digging in why is that and if it affects the actual computation.


\section{Allocator complains \& Optimizing non-reuired functions}
Since some WASM VMs don't provide allocation for additional resources, I have traced the source of the allocation, which seems to be the \lstinline{hashbrown} crate. This crate is needed for the \lstinline{ark-poly} crate, which however we don't need since it's only used for the \lstinline{circuit_specific_setup()} and \lstinline{prove()} functions, which have nothing to do with our verifying function. I cannot however infer with the Trait since it's imported from the imported primitives crate. One solution would be to fork both \inl{ark-snark} and \inl{ark-crypto-primitives}, and change the trait to not have those two funcitons. It also seems that we don't need the implementation of \inl{SNARK} for \inl{Groth16} at all.


\section{Projective representation}
Projective representations appears to be the key to porting numbers to the affine representation without iplementing the transformation myself. The \inl{E::G1Projective} and \inl{E::G2Projective} implement the \inl{self.into_affine()} method thorugh inheritance.

Since I can create a field starting from an array of bytes that represent a number:
\begin{lstlisting}
  let tst_bi: Fr = Field::from_random_bytes(&10u8.to_ne_bytes()).unwrap();
\end{lstlisting}

And this results in the following representation:

\begin{lstlisting}
Fp256(BigInteger256([11286724353632239479, 271994586681835377, 4576425507946680135, 164029952815760582]))
\end{lstlisting}

Where \inl{Fp256} is the same of the public inputs, which are aggregated starting from the verifying key's \inl{gamma_abc}.

So I can build the key and then the \inl{prepare_inputs()} aggregates the public inputs to \( \bar{L} \) for me.

The verifying key is made up of \inl{Fp384} types, which we can construct like this:

\begin{lstlisting}
    let numm: Fp384<FqParameters> = Fp384::from_random_bytes(&1u8.to_ne_bytes()).unwrap();
\end{lstlisting}

Even better, we can construct a \inl{G1Affine} directly from the \inl{Fp384} numbers:

\begin{lstlisting}
  fn af<E>(x: &[u8], y: &[u8]) -> G1Affine
  where
  E: PairingEngine,
  {
    G1Affine::new(
    Fp384::from_random_bytes(x).unwrap(),
    Fp384::from_random_bytes(y).unwrap(),
    false,
    )
  }
\end{lstlisting}


\subsection{Final verifying key approach}
So this might be the final approach:

\begin{enumerate}
\item get \( \alpha \ \beta \ \gamma \ \delta \ \gamma_{abc} \) \ as bytes.
\item build the Affine for those
\item use the \inl{G1Affine} and \inl{G2Affine} to build the verifying key.
\end{enumerate}

\subsubsection{Building a G1Affine}
\begin{lstlisting}
  fn af_g1<E>(x: &[u8], y: &[u8]) -> G1Affine
  where
  E: PairingEngine,
  {
    G1Affine::new(
    Fp384::from_random_bytes(x).unwrap(),
    Fp384::from_random_bytes(y).unwrap(),
    false,
    )
  }
\end{lstlisting}

\subsubsection{Building G2Affine}
\begin{lstlisting}
  fn af_g2<E>(c0_x0: &[u8], c1_y0: &[u8], c0_x1: &[u8], c1_y1: &[u8]) -> G2Affine
  where
  E: PairingEngine,
  {
    let x = QuadExtField::new(
    Fp384::from_random_bytes(c0_x0).unwrap(),
    Fp384::from_random_bytes(c1_y0).unwrap(),
    );
    let y = QuadExtField::new(
    Fp384::from_random_bytes(c0_x1).unwrap(),
    Fp384::from_random_bytes(c1_y1).unwrap(),
    );

    G2Affine::new(x, y, false)
  }
\end{lstlisting}

\subsubsection{Building the verifying key test}
Not yet completed, but seems to work correctly:

\begin{lstlisting}
  /// building a verifying key from provided bytes
  pub fn build_vk<E>(
  alpha_b: [&[u8]; 2],
  beta_b: ([&[u8]; 2], [&[u8]; 2]),
  //    gamma_b: ([&[u8]; 2], [&[u8]; 2]),
  //    delta_b: ([&[u8]; 2], [&[u8]; 2]),
  //    gamma_abc_b: Vec<[&[u8]; 2]>,
  //) -> VerifyingKey<E>
  ) where
  E: PairingEngine,
  {
    let alpha = af_g1::<E>(alpha_b[0], alpha_b[1]);
    let beta = af_g2::<E>(beta_b.0[0], beta_b.0[1], beta_b.1[0], beta_b.1[1]);
    println!("{:#?}", beta);
  }

  #[test]
  fn test() {
    build_vk::<Bls12_377>(
    [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
    (
    [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
    [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
    ),
    )
  }

  ... TEST ...
  

  running 1 test
  GroupAffine {
    x: QuadExtField {
      c0: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
      c1: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
    },
    y: QuadExtField {
      c0: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
      c1: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
    },
    infinity: false,
  }
  test verifying_key_wrap::test ... ok


\end{lstlisting}

\subsection{Building a Verifying Key using BLS12_377 as pairing engine}
This is how to successfully build a verifying key starting from an array of bytes using the BLS12_377 curve:

\begin{lstlisting}

/// building a verifying key from provided bytes
pub fn build_vk<E>(
    alpha_b: [&[u8]; 2],
    beta_b: ([&[u8]; 2], [&[u8]; 2]),
    gamma_b: ([&[u8]; 2], [&[u8]; 2]),
    delta_b: ([&[u8]; 2], [&[u8]; 2]),
    gamma_abc_b: &[[&[u8]; 2]],
    //) -> VerifyingKey<E>
) where
    E: PairingEngine,
{
    let alpha = af_g1::<E>(alpha_b[0], alpha_b[1]);
    let beta = af_g2::<E>(beta_b.0[0], beta_b.0[1], beta_b.1[0], beta_b.1[1]);
    let gamma = af_g2::<E>(gamma_b.0[0], gamma_b.0[1], gamma_b.1[0], gamma_b.1[1]);
    let delta = af_g2::<E>(delta_b.0[0], delta_b.0[1], delta_b.1[0], delta_b.1[1]);

    let mut gamma_abc: Vec<GroupProjective<Parameters>> = Vec::new();
    for g in gamma_abc_b {
        gamma_abc.push(af_g1::<E>(g[0], g[1]).into_projective());
    }

    let vk = VerifyingKey::<Bls12_377> {
        alpha_g1: alpha,
        beta_g2: beta,
        gamma_g2: gamma,
        delta_g2: delta,
        gamma_abc_g1: <Bls12_377 as PairingEngine>::G1Projective::batch_normalization_into_affine(
            gamma_abc.as_slice(),
        ),
    };

    println!("{:#?}", vk);
}

#[test]
fn test() {
    build_vk::<Bls12_377>(
        [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        (
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        ),
        (
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        ),
        (
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        ),
        &[[&0u8.to_be_bytes(), &0u8.to_be_bytes()]],
    )
}

... TEST ...

running 1 test
VerifyingKey {
    alpha_g1: GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            ),
        ),
        infinity: false,
    },
    beta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    delta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_abc_g1: [
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            infinity: false,
        },
    ],
}
test verifying_key_wrap::test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

\end{lstlisting}

I have not yet tested it against a ark-groth16-generated verifying key, but plan to do so by comparing a ark-groth16-built verifiying key and one generated by my \inl{build_vk}. That is possible since the \inl{GroupAffine} type implements a \inl{to_string()} method, which seems to return the number as a hash.

\subsubsection{test 0: starting from a ark circuit generated verifying key}

\begin{lstlisting}
GroupAffine(x=Fp384 "(019658A8FE2530371B8B69DDA1EB401D38ADE94CA012341DA661A988219CDEA79CEE092B535FF84E71C2A9A18957B881)", y=Fp384 "(0069110BB0B7540F07D4AA367B6BD0C0DD3F8ADE8BF61CE5BFB718D3A64F7A13D425CC898EA11DCF59A065EEEDF0BB80)")


GroupAffine(x=QuadExtField(Fp384 "(0115B326AC5BD37483FD538B2D1E914BA6F7C863C2F3C2C664B6F718DD270E3BA5BBB456B5DB9EE53A190F79D4C6EC07)" + Fp384 "(01AAC26F963D72A14D3374B8A0E2F3919921848267A146B08F8077183E1EA1F58F4B6E716832254C54CD4B784BB63046)" * u), y=QuadExtField(Fp384 "(00917DE6A0FE407E9AC8661EA4A3CD3A45693AA026CA83AF7537A97079672DF22559AABA58FF1AA657F8F628600C520D)" + Fp384 "(00CD6561476FEA8B20B46675ACA888155C2A3F32C8F0FDAD3EBABAB1CAC3EA8D89CDF16A4D559A727E5BDBAFFD27D357)" * u))


GroupAffine(x=QuadExtField(Fp384 "(0159A72D5384E07E28BBE807D2945A9D5E21A0D3FB230BCABBE3A8669D9772F47D7BBDE56225D0C06D93416604C42CA0)" + Fp384 "(002BEDC636630F36F508ECB593456B31C60E96862E0B1033BAEA9E17C78EF06614A1211BA2A1FA49918B4F30260BB2B9)" * u), y=QuadExtField(Fp384 "(0120FA0A58FA22365481F9BAAF845CBEBCE52791B3C269CB4DA95ADD32611F1554666058A28452CC1ED42DFB7CB0FFC2)" + Fp384 "(00588C780399437031637430EE0D4F427D68B2627D93339FB59C78E3C88CAD08709B3CBF99303E8B7E25286DA29F9C6C)" * u))


GroupAffine(x=QuadExtField(Fp384 "(012F4602517868B27E3F26FE6131EBE79C4C637AA02C85B04433C13903325A06AA31D2B311D5C95A75C4A92143F46DB7)" + Fp384 "(005344DB42F936BC1D1D766255C0C9AA420823921F1A28B56E8C09092EBC7CED987E5C6E0C5C4B61522556656467EF25)" * u), y=QuadExtField(Fp384 "(0108F393A29B95FB6C2AAD2FC7AD516231C85B3C47BAC3EDADEFA20730ED92FB37C36D054A217C0EB39015B5F0490A5B)" + Fp384 "(0130256282E62A9056F5823186D49CD941CA46A7748F3246838A8ED6681383919D5C9BFD4EE89B8D48C960A93227A723)" * u))


+++++++++++++++++++++++

"GroupAffine(x=Fp384 \"(004B363793CEBFE34BCBB3473344E5BA962A068636DE228390DC9E327616454A05F8B6F3EF601E9212CCEF2977B65BAA)\", y=Fp384 \"(002080555C69C79878802E49F5B6A8F6C2D1C9B8CAF48EBF9930F9A6FC02EBE906BCF8DC2F66BBF7374EF8E0BDB6D93A)\")"
+++++++++++++++++++++++

"GroupAffine(x=Fp384 \"(00DCB332C40B11FEEF6F66AF4EC71FE05E2C2828D2035CD6B341494EA27BE24B8FFED97FBED4F77DF823A871D12BD71D)\", y=Fp384 \"(018F59B773DA05F4075C7C1EBEFE3B9A94FBF00B4B4C195F28AE55276D9CD3AE92C17672E8B10E504387202599F16CB2)\")"
VerifyingKey {
    alpha_g1: GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    3199796192684432232,
                    4362044476736311684,
                    8571585415345326572,
                    272761253199814039,
                    14270748742047465361,
                    66582167681461772,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    17201133494176990532,
                    17361089997485303489,
                    2356170384171249648,
                    15902542869977172799,
                    4538038237916000288,
                    111600171191049399,
                ],
            ),
        ),
        infinity: false,
    },
    beta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15665539495786463071,
                        5351637199640705349,
                        5481305661085202947,
                        7252742268448139825,
                        14247290886710085473,
                        8228118271073905,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        8494150025713109519,
                        10006396386444051476,
                        13426536016117885356,
                        14412411855199552289,
                        6775472512520061513,
                        74820872700629732,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15935296043123816371,
                        16352348468216685567,
                        18366972020740145783,
                        466661810096455046,
                        2878395169732749912,
                        8930570229618427,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5497740038271589360,
                        17915564786368593018,
                        6498524887710276130,
                        8426407821033307682,
                        16967503410483070288,
                        87176449986178953,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        9871853462335952088,
                        13818766888080895758,
                        17438042164113238682,
                        18189658193228720557,
                        2525422391418593468,
                        24523991538162966,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        11598746871527494840,
                        7034886688852915957,
                        12879249698997281788,
                        4163459272077291496,
                        8651220120244872545,
                        59915112257360239,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        7950359384402899170,
                        13996412715721629044,
                        6496880002162414242,
                        18295956382737944941,
                        2234543578719997617,
                        42753032893982425,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        10705544008056969210,
                        9200130017538406234,
                        11564099230850897960,
                        14834164197102901648,
                        8879627515244002516,
                        35758504385251159,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    delta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        17378376314876687378,
                        16973419638754281229,
                        14270724477782754208,
                        2501781286801870373,
                        15494869354494408847,
                        55959435810413563,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5502086789033988657,
                        14858517976162320987,
                        15404109653845145200,
                        2764116950063500718,
                        6191383125089685741,
                        50035813276305954,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        6015129980063650823,
                        16508026119111894092,
                        2188668545527179262,
                        6083766794835601109,
                        5406935781835772749,
                        5367335577955122,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        988948364683663604,
                        18317168497480206806,
                        1717381988724736342,
                        7919953277030105370,
                        568824204833211202,
                        155794729479942,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_abc_g1: [
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        11799971873841990394,
                        257913239514469713,
                        14278748961702997970,
                        5223660586048483536,
                        4755949232771428869,
                        55376713287789687,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        7153500734298768415,
                        12003322931069364582,
                        2971060553454058512,
                        10964891730829161335,
                        4028692683660537851,
                        108252529747732483,
                    ],
                ),
            ),
            infinity: false,
        },
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        12989544681776788439,
                        13832684143667388616,
                        3659190950442991324,
                        8388909368244242073,
                        14278530298672880819,
                        48707499247719728,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        1615753075891152131,
                        1664066684894824792,
                        13574419005665713030,
                        16927252680167286359,
                        3299211563813464259,
                        104982182247700143,
                    ],
                ),
            ),
            infinity: false,
        },
    ],
}
\end{lstlisting}

With a small change in the \inl{build_vk()} fn to accept \inl{&str} instead of \inl{&[u8]}, it works successfully (skipped the gamma_abc field since it's already confirmed it works).

\begin{lstlisting}
#[test]
fn test() {
    build_vk::<Bls12_377>(
        ["244306343969063579670721716785298378635493726975886604273579756741639953229415532528173059841495385161051909109889", "63168857095591134725408337287692176528875980900624529853774760091869452188562350014800651918572654790783920028544"],
        (
            ["166960595540395913540723923566898026573424078512165798770235854040187289225192916010951416820805112564604857674759", "256579300865415868978670925736320544320874294516177433193882034907441551828751116120797786447763257652992433074246"],
            ["87473584283475883633210079642084278881337869703101638340970998916304987007252265651123549659939971414867340710413", "123489609982310436708723271094904270617390265200237414568574960565923435716212526049371801011721780033997716837207"],
        ),
        (
            ["207815903344640726299046137491517455777565280776268931869703062519065330398931946294820126450478727867816749575328", "26411179743201816196117502737770454887025628039998868349298819832115736570578946577905207881058063637557577233081"],
            ["173740578116962590398112557239635940705266404600901213439034068175852581397457477553437876533246152293969399185346", "53237864274615109658005039249476166763817121546091535441125115325245366998581238918446431741630833736330879409260"],
        ),
        (
            ["182336170308948313274124544129583724669150178188157754550801543744233234403657037451296838109344679861568207613367", "50063545199251041371514525798326822749409640809082086310504485485918817418911777413389911727510843283856035409701"],
            ["159295952166184899549579271167219255119055500588829231155055479006308616522384365458479858992918918801397710916187", "182860777779699565903677389365895752934510027123821576636249379548577596319261062512490971767063470277595543086883"]
        ),
        &[["0", "0"]],
    )
}

\end{lstlisting}

\section{Proof verification tests}

After having gotten comfortable with the crates' design and types, we're ready to go verifying an actual zk-SNARK.

\subsection{0}

this is the first test, which again involves verifying an ark-generated proof, this is the verifying key ( \( \alpha, \ \beta, \ \gamma, \ \delta \) +++++ \( \gamma_{abc} \) ) for \inl{gamma_abc}, the proof (a, b, c), and the image.

\begin{lstlisting}
GroupAffine(x=Fp384 "(019658A8FE2530371B8B69DDA1EB401D38ADE94CA012341DA661A988219CDEA79CEE092B535FF84E71C2A9A18957B881)", y=Fp384 "(0069110BB0B7540F07D4AA367B6BD0C0DD3F8ADE8BF61CE5BFB718D3A64F7A13D425CC898EA11DCF59A065EEEDF0BB80)")


GroupAffine(x=QuadExtField(Fp384 "(0115B326AC5BD37483FD538B2D1E914BA6F7C863C2F3C2C664B6F718DD270E3BA5BBB456B5DB9EE53A190F79D4C6EC07)" + Fp384 "(01AAC26F963D72A14D3374B8A0E2F3919921848267A146B08F8077183E1EA1F58F4B6E716832254C54CD4B784BB63046)" * u), y=QuadExtField(Fp384 "(00917DE6A0FE407E9AC8661EA4A3CD3A45693AA026CA83AF7537A97079672DF22559AABA58FF1AA657F8F628600C520D)" + Fp384 "(00CD6561476FEA8B20B46675ACA888155C2A3F32C8F0FDAD3EBABAB1CAC3EA8D89CDF16A4D559A727E5BDBAFFD27D357)" * u))


GroupAffine(x=QuadExtField(Fp384 "(0159A72D5384E07E28BBE807D2945A9D5E21A0D3FB230BCABBE3A8669D9772F47D7BBDE56225D0C06D93416604C42CA0)" + Fp384 "(002BEDC636630F36F508ECB593456B31C60E96862E0B1033BAEA9E17C78EF06614A1211BA2A1FA49918B4F30260BB2B9)" * u), y=QuadExtField(Fp384 "(0120FA0A58FA22365481F9BAAF845CBEBCE52791B3C269CB4DA95ADD32611F1554666058A28452CC1ED42DFB7CB0FFC2)" + Fp384 "(00588C780399437031637430EE0D4F427D68B2627D93339FB59C78E3C88CAD08709B3CBF99303E8B7E25286DA29F9C6C)" * u))


GroupAffine(x=QuadExtField(Fp384 "(012F4602517868B27E3F26FE6131EBE79C4C637AA02C85B04433C13903325A06AA31D2B311D5C95A75C4A92143F46DB7)" + Fp384 "(005344DB42F936BC1D1D766255C0C9AA420823921F1A28B56E8C09092EBC7CED987E5C6E0C5C4B61522556656467EF25)" * u), y=QuadExtField(Fp384 "(0108F393A29B95FB6C2AAD2FC7AD516231C85B3C47BAC3EDADEFA20730ED92FB37C36D054A217C0EB39015B5F0490A5B)" + Fp384 "(0130256282E62A9056F5823186D49CD941CA46A7748F3246838A8ED6681383919D5C9BFD4EE89B8D48C960A93227A723)" * u))


+++++++++++++++++++++++

"GroupAffine(x=Fp384 \"(004B363793CEBFE34BCBB3473344E5BA962A068636DE228390DC9E327616454A05F8B6F3EF601E9212CCEF2977B65BAA)\", y=Fp384 \"(002080555C69C79878802E49F5B6A8F6C2D1C9B8CAF48EBF9930F9A6FC02EBE906BCF8DC2F66BBF7374EF8E0BDB6D93A)\")"
+++++++++++++++++++++++

"GroupAffine(x=Fp384 \"(00DCB332C40B11FEEF6F66AF4EC71FE05E2C2828D2035CD6B341494EA27BE24B8FFED97FBED4F77DF823A871D12BD71D)\", y=Fp384 \"(018F59B773DA05F4075C7C1EBEFE3B9A94FBF00B4B4C195F28AE55276D9CD3AE92C17672E8B10E504387202599F16CB2)\")"
Creating proofs...
Proof:

"GroupAffine(x=Fp384 \"(0004B2425C43BD6ECC82CBA1336DD0C5818F27609EC016D2B2F9749B5D06EB038AA3D54CEF0532B301A3CC7B71553914)\", y=Fp384 \"(01AB2FDF2104E30EE2D1DC9F6F08729A80357792233869E0CCA6F207EBB9FE90471D80E1769337B279568C548EBE4DFD)\")"
"GroupAffine(x=QuadExtField(Fp384 \"(0033BD48BC15D11E880E87E6FD7071A11AF07ED6723799B136C8AE383DEE640EB8C9A70D269CE7485285FED7B521D2B7)\" + Fp384 \"(00B935EDAA87436E5C13E3B26E2F33AC8266226FEA5B13963B24B469944B07ED69A754B53FF0F52C4CFCD1C674A08531)\" * u), y=QuadExtField(Fp384 \"(0098EA43EFDCE92DFC321A7F0669F6450DBE9B51A0F22C32BD22FABBD74EDEBD7FDE6B56A672EFDE149BBE09249BEB22)\" + Fp384 \"(015B01AFAECBD2FA537B31772B862333521A8AD391FE936D329511487B80B70819AF48667C13537F345713F8DF16233D)\" * u))"
"GroupAffine(x=Fp384 \"(00A3F11F2C9F81E09FA190C7C52835D34E6C52D7A51091730EA5E611B4F81F19587C7962F87EAA6E53030AFFD75612EF)\", y=Fp384 \"(0190EB519B7302A77C0B643AE016999845753E7FF8D6E4DD5B5F099037FA89BBDF226E0F9EABB3A0C66785A25519B7BE)\")"
Image:

"Fp256 \"(01DEE28997F2F4574107971F0ADD09CEB5780448D2EABB6805B44C3F29194F37)\""

\subsubsection{Results: tests passed}
The following tests prove the validity or invalidity of a proof given the verifying key, the proof and the public inputs:

\begin{lstlisting}
  #[test]
  fn test_proof_verify_correct() {
    use crate::proof_wrap::build_proof;

    let vk = build_vk::<Bls12_377>(
    ["244306343969063579670721716785298378635493726975886604273579756741639953229415532528173059841495385161051909109889", "63168857095591134725408337287692176528875980900624529853774760091869452188562350014800651918572654790783920028544"],
    (
    ["166960595540395913540723923566898026573424078512165798770235854040187289225192916010951416820805112564604857674759", "256579300865415868978670925736320544320874294516177433193882034907441551828751116120797786447763257652992433074246"],
    ["87473584283475883633210079642084278881337869703101638340970998916304987007252265651123549659939971414867340710413", "123489609982310436708723271094904270617390265200237414568574960565923435716212526049371801011721780033997716837207"],
    ),
    (
    ["207815903344640726299046137491517455777565280776268931869703062519065330398931946294820126450478727867816749575328", "26411179743201816196117502737770454887025628039998868349298819832115736570578946577905207881058063637557577233081"],
    ["173740578116962590398112557239635940705266404600901213439034068175852581397457477553437876533246152293969399185346", "53237864274615109658005039249476166763817121546091535441125115325245366998581238918446431741630833736330879409260"],
    ),
    (
    ["182336170308948313274124544129583724669150178188157754550801543744233234403657037451296838109344679861568207613367", "50063545199251041371514525798326822749409640809082086310504485485918817418911777413389911727510843283856035409701"],
    ["159295952166184899549579271167219255119055500588829231155055479006308616522384365458479858992918918801397710916187", "182860777779699565903677389365895752934510027123821576636249379548577596319261062512490971767063470277595543086883"]
    ),
    &[["45219348755244176666833458629810173891297212875931990204868267536335133459926383707224440114114434942676491459498", "19540657389919455835633145166127846278689061111248765380940010308445770554757443738413976319711696645309607631162"], ["132690773109251177890733778816628496635591484623891382110461401031465056699668313488237840261951485844724629886749", "240100236857354300144167057024140952061824175420694647234861063227513152232079560535186470882088794992850790083762"]],
    );
    let prep_vk = prepare_verifying_key(&vk);

    let proof = build_proof::<Bls12_377>(
    ["2823556974515544774097151763008346382538217401273878490225566812766536738796196154138387932214916091703926798612", "256836315293598409442945070471502389713143573948685505143875387508159714195596227342715425692593966353228874272253"],
    (
    ["31107113776647024754132649063812192258461504726214621117956031386610890802548704229846887183629711420377939432119", "111353629824784130583952282242830150973347288965763462424086954686454292967282100836332310927094987906314221421873"],
    ["91936671198601450749375295715973976584274138653454658623943122925191168704925205918404144895071632258580325591842", "208629694968560609178904490188735063849504070877826668635449017509939169002653787652914605885048807640820436312893"]
    ),
    ["98566269649372170007611478342378468911358117139006469753077039249660968858754944774214496198826225135709632991983", "241043416647210531433151402812182928061728807543600376342543797314183884387241527972417219291397635999358690899902"]
    );

    let image: Fr = Fp256::from_str(
    "846116401153237484849669029241028974706836885357063726500585263672059318071",
    )
    .unwrap();

    assert!(verify_proof(&prep_vk, &proof, &[image]).unwrap());

    //    println!("{:#?} {:?}", proof, image.to_string());
  }

  ... TEST ...

  running 1 test
  test verifying_key_wrap::test_proof_verify_correct ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.04s

  
\end{lstlisting}

\begin{lstlisting}
  
  #[test]
  fn test_proof_verify_incorrect() {
    use crate::proof_wrap::build_proof;

    let vk = build_vk::<Bls12_377>(
    ["244306343969063579670721716785298378635493726975886604273579756741639953229415532528173059841495385161051909109889", "63168857095591134725408337287692176528875980900624529853774760091869452188562350014800651918572654790783920028544"],
    (
    ["166960595540395913540723923566898026573424078512165798770235854040187289225192916010951416820805112564604857674759", "256579300865415868978670925736320544320874294516177433193882034907441551828751116120797786447763257652992433074246"],
    ["87473584283475883633210079642084278881337869703101638340970998916304987007252265651123549659939971414867340710413", "123489609982310436708723271094904270617390265200237414568574960565923435716212526049371801011721780033997716837207"],
    ),
    (
    ["207815903344640726299046137491517455777565280776268931869703062519065330398931946294820126450478727867816749575328", "26411179743201816196117502737770454887025628039998868349298819832115736570578946577905207881058063637557577233081"],
    ["173740578116962590398112557239635940705266404600901213439034068175852581397457477553437876533246152293969399185346", "53237864274615109658005039249476166763817121546091535441125115325245366998581238918446431741630833736330879409260"],
    ),
    (
    ["182336170308948313274124544129583724669150178188157754550801543744233234403657037451296838109344679861568207613367", "50063545199251041371514525798326822749409640809082086310504485485918817418911777413389911727510843283856035409701"],
    ["159295952166184899549579271167219255119055500588829231155055479006308616522384365458479858992918918801397710916187", "182860777779699565903677389365895752934510027123821576636249379548577596319261062512490971767063470277595543086883"]
    ),
    &[["45219348755244176666833458629810173891297212875931990204868267536335133459926383707224440114114434942676491459498", "19540657389919455835633145166127846278689061111248765380940010308445770554757443738413976319711696645309607631162"], ["132690773109251177890733778816628496635591484623891382110461401031465056699668313488237840261951485844724629886749", "240100236857354300144167057024140952061824175420694647234861063227513152232079560535186470882088794992850790083762"]],
    );
    let prep_vk = prepare_verifying_key(&vk);

    let proof = build_proof::<Bls12_377>(
    ["2823556974515544774097151763008346382538217401273878490225566812766536738796196154138387932214916091703926798612", "256836315293598409442945070471502389713143573948685505143875387508159714195596227342715425692593966353228874272253"],
    (
    ["31107113776647024754132649063812192258461504726214621117956031386610890802548704229846887183629711420377939432119", "111353629824784130583952282242830150973347288965763462424086954686454292967282100836332310927094987906314221421873"],
    ["91936671198601450749375295715973976584274138653454658623943122925191168704925205918404144895071632258580325591842", "208629694968560609178904490188735063849504070877826668635449017509939169002653787652914605885048807640820436312893"]
    ),
    ["98566269649372170007611478342378468911358117139006469753077039249660968858754944774214496198826225135709632991983", "241043416647210531433151402812182928061728807543600376342543797314183884387241527972417219291397635999358690899902"]
    );

    let image: Fr = Fp256::from_str(
    "846116401153237484849669029241028974706836885357063726500585263672059318072", // changed the last digit
    )
    .unwrap();

    assert_eq!(verify_proof(&prep_vk, &proof, &[image]).unwrap(), false);

    //    println!("{:#?} {:?}", proof, image.to_string());
  }

  ... TEST ...

  running 1 test
  test verifying_key_wrap::test_proof_verify_incorrect ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.05s

\end{lstlisting}

\end{document}
