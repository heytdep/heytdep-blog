\documentclass{article}

\usepackage{listings, listings-rust}
\usepackage{amsmath}% http://ctan.org/pkg/amsmath
\usepackage{color}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}  
\lstset{  
tabsize=4,  
basicstyle=\ttfamily,  
backgroundcolor=\color{lbcolor},  
showstringspaces=false  
}
\newcommand{\inl}[1]{\lstinline{#1}}
\newcommand{\thickbar}[1]{\mathbf{\bar{\text{$#1$}}}}

\title{Zokrates+Rust+WASM}
\date{29/08/2022}

\begin{document}
\maketitle

\texttt{29 aug 2022}

\section{Introduction}

Personal notes on writing a Rust verifier for zokrates-generated veryifing key and proof, depending on my \lstinline{ark-groth16} fork. The fork is designed to target WebAssembly, effectively making it easily cross-platform without issues, furthermore it leverages the amazing work from the people at arkworks and isn't depentent on Rust's standard library.

\section{Workflow}
\lstinline{arg-groth16}'s \lstinline{verify_proof/3} function accepts three parameters: a \lstinline{PreparedVerifyingKey} struct, the proof and the public inputs (these two have a familiar look).

The function seems to only accept the public inputs in a raw format, while the verifying key must be prepared before through the \lstinline{prepare_verifying_key/1} function, which accepts a \lstinline{VerifyingKey} struct, which has a familiar look (to the one built by zokrates).

It's also worth noting that arkworks doesn't seem to have implemented the \lstinline{alt_bn128} curve, probably also because it doesn't \href{https://moderncrypto.org/mail-archive/curves/2016/000740.html}{actually} target 128bit security.

\section{Possible Approach}
Firstly, one should remember to compile the \lstinline{zok} code with the \lstinline{--curve bls12_377} or \lstinline{--curve bls12_381}. Secondly, convert zokrates' output from hexadecimal to decimal numbers.

\subsection{Building required structs}

\subsubsection{context}
\begin{lstlisting}[rust]
  pub struct Proof<E: PairingEngine> {
    /// The `A` element in `G1`.
    pub a: E::G1Affine,
    /// The `B` element in `G2`.
    pub b: E::G2Affine,
    /// The `C` element in `G1`.
    pub c: E::G1Affine,
  }

  pub struct VerifyingKey<E: PairingEngine> {
    /// The `alpha * G`, where `G` is the generator of `E::G1`.
    pub alpha_g1: E::G1Affine,
    /// The `alpha * H`, where `H` is the generator of `E::G2`.
    pub beta_g2: E::G2Affine,
    /// The `gamma * H`, where `H` is the generator of `E::G2`.
    pub gamma_g2: E::G2Affine,
    /// The `delta * H`, where `H` is the generator of `E::G2`.
    pub delta_g2: E::G2Affine,
    /// The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where `H` is the generator of `E::G1`.
    pub gamma_abc_g1: Vec<E::G1Affine>,
  }

  pub struct PreparedVerifyingKey<E: PairingEngine> {
    /// The unprepared verification key.
    pub vk: VerifyingKey<E>,
    /// The element `e(alpha * G, beta * H)` in `E::GT`.
    pub alpha_g1_beta_g2: E::Fqk,
    /// The element `- gamma * H` in `E::G2`, prepared for use in pairings.
    pub gamma_g2_neg_pc: E::G2Prepared,
    /// The element `- delta * H` in `E::G2`, prepared for use in pairings.
    pub delta_g2_neg_pc: E::G2Prepared,
  }
  
  ...
  
  pub fn verify_proof<E: PairingEngine>(
    pvk: &PreparedVerifyingKey<E>,
    proof: &Proof<E>,
    public_inputs: &[E::Fr],
  ) -> R1CSResult<bool> {
    let prepared_inputs = prepare_inputs(pvk, public_inputs)?;
    verify_proof_with_prepared_inputs(pvk, proof, &prepared_inputs)
  }

\end{lstlisting}

Where a \lstinline{G1Affine} type looks like this:

\begin{lstlisting}
    GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    3199796192684432232,
                    4362044476736311684,
                    8571585415345326572,
                    272761253199814039,
                    14270748742047465361,
                    66582167681461772,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    17201133494176990532,
                    17361089997485303489,
                    2356170384171249648,
                    15902542869977172799,
                    4538038237916000288,
                    111600171191049399,
                ],
            ),
        ),
        infinity: false,
    },

\end{lstlisting}

And a \lstinline{G2Affine} looks like this:

\begin{lstlisting}
    GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15665539495786463071,
                        5351637199640705349,
                        5481305661085202947,
                        7252742268448139825,
                        14247290886710085473,
                        8228118271073905,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        8494150025713109519,
                        10006396386444051476,
                        13426536016117885356,
                        14412411855199552289,
                        6775472512520061513,
                        74820872700629732,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        15935296043123816371,
                        16352348468216685567,
                        18366972020740145783,
                        466661810096455046,
                        2878395169732749912,
                        8930570229618427,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        5497740038271589360,
                        17915564786368593018,
                        6498524887710276130,
                        8426407821033307682,
                        16967503410483070288,
                        87176449986178953,
                    ],
                ),
            ),
        },
        infinity: false,
    },

\end{lstlisting}

\textbf{Note}: the \lstinline{BigInteger384} type seems to hold the actual number as an array of smaller numbers (similar to what's being done with Soroban's u256 integers). In fact, an array exacly corresponds to a zokrates generated one (after being converted to decimal).

\textbf{Note}: the length of the numbers in \lstinline{BigInteger384}'s array varies between 17 and 20, I should do some digging in why is that and if it affects the actual computation.


\section{Allocator complains \& Optimizing non-reuired functions}
Since some WASM VMs don't provide allocation for additional resources, I have traced the source of the allocation, which seems to be the \lstinline{hashbrown} crate. This crate is needed for the \lstinline{ark-poly} crate, which however we don't need since it's only used for the \lstinline{circuit_specific_setup()} and \lstinline{prove()} functions, which have nothing to do with our verifying function. I cannot however infer with the Trait since it's imported from the imported primitives crate. One solution would be to fork both \inl{ark-snark} and \inl{ark-crypto-primitives}, and change the trait to not have those two funcitons. It also seems that we don't need the implementation of \inl{SNARK} for \inl{Groth16} at all.


\section{Projective representation}
Projective representations appears to be the key to porting numbers to the affine representation without iplementing the transformation myself. The \inl{E::G1Projective} and \inl{E::G2Projective} implement the \inl{self.into_affine()} method thorugh inheritance.

Since I can create a field starting from an array of bytes that represent a number:
\begin{lstlisting}
  let tst_bi: Fr = Field::from_random_bytes(&10u8.to_ne_bytes()).unwrap();
\end{lstlisting}

And this results in the following representation:

\begin{lstlisting}
Fp256(BigInteger256([11286724353632239479, 271994586681835377, 4576425507946680135, 164029952815760582]))
\end{lstlisting}

Where \inl{Fp256} is the same of the public inputs, which are aggregated starting from the verifying key's \inl{gamma_abc}.

So I can build the key and then the \inl{prepare_inputs()} aggregates the public inputs to \( \bar{L} \) for me.

The verifying key is made up of \inl{Fp384} types, which we can construct like this:

\begin{lstlisting}
    let numm: Fp384<FqParameters> = Fp384::from_random_bytes(&1u8.to_ne_bytes()).unwrap();
\end{lstlisting}

Even better, we can construct a \inl{G1Affine} directly from the \inl{Fp384} numbers:

\begin{lstlisting}
  fn af<E>(x: &[u8], y: &[u8]) -> G1Affine
  where
  E: PairingEngine,
  {
    G1Affine::new(
    Fp384::from_random_bytes(x).unwrap(),
    Fp384::from_random_bytes(y).unwrap(),
    false,
    )
  }
\end{lstlisting}


\subsection{Final verifying key approach}
So this might be the final approach:

\begin{enumerate}
\item get \( \alpha \ \beta \ \gamma \ \delta \ \gamma_{abc} \) \ as bytes.
\item build the Affine for those
\item use the \inl{G1Affine} and \inl{G2Affine} to build the verifying key.
\end{enumerate}

\subsubsection{Building a G1Affine}
\begin{lstlisting}
  fn af_g1<E>(x: &[u8], y: &[u8]) -> G1Affine
  where
  E: PairingEngine,
  {
    G1Affine::new(
    Fp384::from_random_bytes(x).unwrap(),
    Fp384::from_random_bytes(y).unwrap(),
    false,
    )
  }
\end{lstlisting}

\subsubsection{Building G2Affine}
\begin{lstlisting}
  fn af_g2<E>(c0_x0: &[u8], c1_y0: &[u8], c0_x1: &[u8], c1_y1: &[u8]) -> G2Affine
  where
  E: PairingEngine,
  {
    let x = QuadExtField::new(
    Fp384::from_random_bytes(c0_x0).unwrap(),
    Fp384::from_random_bytes(c1_y0).unwrap(),
    );
    let y = QuadExtField::new(
    Fp384::from_random_bytes(c0_x1).unwrap(),
    Fp384::from_random_bytes(c1_y1).unwrap(),
    );

    G2Affine::new(x, y, false)
  }
\end{lstlisting}

\subsubsection{Building the verifying key test}
Not yet completed, but seems to work correctly:

\begin{lstlisting}
  /// building a verifying key from provided bytes
  pub fn build_vk<E>(
  alpha_b: [&[u8]; 2],
  beta_b: ([&[u8]; 2], [&[u8]; 2]),
  //    gamma_b: ([&[u8]; 2], [&[u8]; 2]),
  //    delta_b: ([&[u8]; 2], [&[u8]; 2]),
  //    gamma_abc_b: Vec<[&[u8]; 2]>,
  //) -> VerifyingKey<E>
  ) where
  E: PairingEngine,
  {
    let alpha = af_g1::<E>(alpha_b[0], alpha_b[1]);
    let beta = af_g2::<E>(beta_b.0[0], beta_b.0[1], beta_b.1[0], beta_b.1[1]);
    println!("{:#?}", beta);
  }

  #[test]
  fn test() {
    build_vk::<Bls12_377>(
    [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
    (
    [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
    [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
    ),
    )
  }

  ... TEST ...
  

  running 1 test
  GroupAffine {
    x: QuadExtField {
      c0: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
      c1: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
    },
    y: QuadExtField {
      c0: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
      c1: Fp384(
      BigInteger384(
      [
        0,
        0,
        0,
        0,
        0,
        0,
      ],
      ),
      ),
    },
    infinity: false,
  }
  test verifying_key_wrap::test ... ok


\end{lstlisting}

\subsection{Building a Verifying Key using BLS12_377 as pairing engine}
This is how to successfully build a verifying key starting from an array of bytes using the BLS12_377 curve:

\begin{lstlisting}

/// building a verifying key from provided bytes
pub fn build_vk<E>(
    alpha_b: [&[u8]; 2],
    beta_b: ([&[u8]; 2], [&[u8]; 2]),
    gamma_b: ([&[u8]; 2], [&[u8]; 2]),
    delta_b: ([&[u8]; 2], [&[u8]; 2]),
    gamma_abc_b: &[[&[u8]; 2]],
    //) -> VerifyingKey<E>
) where
    E: PairingEngine,
{
    let alpha = af_g1::<E>(alpha_b[0], alpha_b[1]);
    let beta = af_g2::<E>(beta_b.0[0], beta_b.0[1], beta_b.1[0], beta_b.1[1]);
    let gamma = af_g2::<E>(gamma_b.0[0], gamma_b.0[1], gamma_b.1[0], gamma_b.1[1]);
    let delta = af_g2::<E>(delta_b.0[0], delta_b.0[1], delta_b.1[0], delta_b.1[1]);

    let mut gamma_abc: Vec<GroupProjective<Parameters>> = Vec::new();
    for g in gamma_abc_b {
        gamma_abc.push(af_g1::<E>(g[0], g[1]).into_projective());
    }

    let vk = VerifyingKey::<Bls12_377> {
        alpha_g1: alpha,
        beta_g2: beta,
        gamma_g2: gamma,
        delta_g2: delta,
        gamma_abc_g1: <Bls12_377 as PairingEngine>::G1Projective::batch_normalization_into_affine(
            gamma_abc.as_slice(),
        ),
    };

    println!("{:#?}", vk);
}

#[test]
fn test() {
    build_vk::<Bls12_377>(
        [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        (
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        ),
        (
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        ),
        (
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
            [&0u8.to_be_bytes(), &0u8.to_be_bytes()],
        ),
        &[[&0u8.to_be_bytes(), &0u8.to_be_bytes()]],
    )
}

... TEST ...

running 1 test
VerifyingKey {
    alpha_g1: GroupAffine {
        x: Fp384(
            BigInteger384(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            ),
        ),
        y: Fp384(
            BigInteger384(
                [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ],
            ),
        ),
        infinity: false,
    },
    beta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    delta_g2: GroupAffine {
        x: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        y: QuadExtField {
            c0: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            c1: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
        },
        infinity: false,
    },
    gamma_abc_g1: [
        GroupAffine {
            x: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            y: Fp384(
                BigInteger384(
                    [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                    ],
                ),
            ),
            infinity: false,
        },
    ],
}
test verifying_key_wrap::test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

\end{lstlisting}

I have not yet tested it against a ark-groth16-generated verifying key, but plan to do so by comparing a ark-groth16-built verifiying key and one generated by my \inl{build_vk}. That is possible since the \inl{GroupAffine} type implements a \inl{to_string()} method, which seems to return the number as a hash.

\end{document}
